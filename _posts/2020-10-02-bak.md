<!-- ---
title:  "[2020] 第12屆鐵人賽Day 19 Rails專案開發 - 建立Column的Vue元件"
preview: ""
permalink: ""
date:   2020-09-30 10:00:00
layout: post
tags: 
  - "rail"
  - "vue"    
--- -->


在昨天的時候把看板`Kanban`的CRUD搞定。
在MVC架構裡，model是我們放商業邏輯的地方，所以第一步就是要決定這個網站的核心邏輯。

# 建立Model

- 使用者可以建立很多`Kanban`
- 看板`Kanban`可以有很多`Column`
- 每個`Column`可以有很多張票`Ticket`。

kanban.rb

每個kanban有很多columns, 根據`dependent`，如果刪掉了kanban，column也就一起刪掉

```
class Kanban < ApplicationRecord
  has_many :columns, -> { order(position: :asc)}, dependent: :destroy
  belongs_to :user
  validates :name, presence: true
end
```

column.rb

每個column有很多ticket, 根據`dependent`，如果刪掉了column，ticket也就一起刪掉
```
class Column < ApplicationRecord
  has_many :tickets, -> { order(position: :asc)}, dependent: :destroy
  belongs_to :kanban
  validates :name, presence: true  
end
```

ticket.rb
```
class Ticket < ApplicationRecord
  belongs_to :column
  validates :name, presence: true  
end
```

# act_as_list
```
https://github.com/brendon/acts_as_list
https://rubygems.org/gems/acts_as_list/versions/1.0.0

gem 'acts_as_list', '~> 1.0'
```


# 在rails c建立column和list

我們想要抓出`id=1`使用者的第二個看板，並在裡面建立column和list
```
> u1 = User.first
=> #<User id: 1, email: "秘密", created_at: "2020-10-01 01:43:03", updated_at: "2020-10-01 07:12:27", name: "Ting">

> k2 = u1.kanbans.find 2

=> #<Kanban:0x00007fa40f8e4df0
 id: 2,
 name: "Vue.js feat. Rails專案",
 description:
  "相對容易上手的前端框架Vue.js，要如何整合網站後端開發最迅速的框架Rails呢？讓我們用30天來探索及實作～來一場「VR」Vue.js feat. Ruby on Rails前端後端交響曲吧！",
```

根據想致敬的trello`Software Development` template:

![](https://i.imgur.com/TP0g3qY.png) 

```
> k2.columns.create(name: "Backlog")
> k2.columns.create(name: "Sprint Backlog")
> k2.columns.create(name: "Working On")
> k2.columns.create(name: "Bugs")
> k2.columns.create(name: "Testing")
> k2.columns.create(name: "Done")
```

## 點擊dashboard的kanban，可導向該看板的column

![](https://i.imgur.com/FLhVM0s.png)

conlumns_controller.rb
```
  def index
    @kanban = Kanban.find(params[:kanban_id])    
    @columns = @kanban.columns.all
  end
```

# 設計routes
```
Rails.application.routes.draw do

  resources :kanbans do
    resources :columns, except: [:new, :edit] do
      member do
        put :shift
      end
    end

    resources :tickets, only: [:create, :update, :destroy] do
      member do
        put :shift
      end
    end
  end

  devise_for :users
  root 'pages#index'
  get "dashboard", to: "pages#dashboard"
end
```
# rails 的寫法

columns#index.html.erb
```
<div class="mt-2 px-3 flex">
  <% @columns.each do |column| %>
    <div class="bg-teal-100 mx-2 w-64 rounded">
      <div class="px-3 py-2 font-thin"><%= column.name %></div>
    </div>
  <% end %>
</div>
```

# 改寫成 Vue的寫法: 利用data-set

application.js

```
import Vue from "vue/dist/vue.esm";

document.addEventListener("turbolinks:load", () => {
  let el = document.querySelector("#column");
  if (el){
    new Vue({
      el,
      data: {
        columns: JSON.parse(el.dataset.columns)
      }
    });
  }
})
```

columns#index.html.erb
```
<div id="column" class="mt-2 px-3 flex" data-columns="<%= @columns.to_json(include: :tickets)%>">
  <div class="bg-teal-100 mx-2 w-64 rounded"  v-for="column in columns">
    <div class="px-3 py-2 font-thin">{{ column.name }}</div>
  </div>
</div>
```

# 改寫成Vue Component: Column

components/kanban/column.vue

```
<template>
  <div class="column">
    <div class="column-name">{{ column.name }}</div>
  </div>
</template>

<script>
  // 讓用元件的父層，餵資料給子元件
  export default {              
    name: 'Column',
    props: ["column"]
    // 每個元件都有自己的狀態和資料，所以data需要給一個能return值回去的function, 
    // data: function () {
    //   return {
    //     column: this.column   
    //   }
    // }
  }
</script>

<style lang="scss" scoped>
  .column{
    @apply .bg-teal-100 .mx-2 .w-64 .rounded;

    .column-name{
      @apply .px-3 .py-2 .font-thin;
    }
  }
</style>
```

packs/application.js

```
require("@rails/ujs").start()
require("turbolinks").start()
require("@rails/activestorage").start()
require("channels")

const images = require.context('../images', true)
const imagePath = (name) => images(name, true)

import 'scripts'
import 'styles'

import Vue from "vue/dist/vue.esm";
import Column from "components/kanban/column"

document.addEventListener("turbolinks:load", () => {
  let el = document.querySelector("#column");
  if (el){
    new Vue({
      el,
      data: {
        columns: JSON.parse(el.dataset.columns)
      },
      components: { Column }
    });
  }
})
```

columns#index.html.erb
```
<p id="notice"><%= notice %></p>

<div id="column" class="mt-2 px-3 flex" data-columns="<%= @columns.to_json(include: :tickets)%>">
  <Column v-for="column in columns" :column="column" :key="column.id"></Column>  
</div>

<br>
```

![](https://i.imgur.com/BDCuR5f.png)

如何不要用data-set來做component?



# 利用 Vue.js Lifecycle的概念，改寫成Vue的 Column Component

我們的元件已經有`el`：element了，
接著要決定，請Vue.js在適當的時機點(beforeMount)把資料抓回來

Mounting: 掛載階段，代表Vue.js要控制template/div之前  

![](https://i.imgur.com/nBoMs75.png)

| hooks | 用途 |
| -------- | -------- |
| beforeMount     |  在執行元素掛載，畫面渲染至瀏覽器前的階段，此時render method第一次被呼叫，可以讓我們預處理DOM。   |
| mounted     | 元素已掛載，`el`建立完成。     |


## column vue元件的資料要從哪裡得到呢?

app/views/columns/_column.json.jbuilder

跟據專案的路徑設計，把`json.url`改為可以正確取到json的位置
```
json.extract! column, :id, :name, :kanban_id
json.url kanban_columns_path(column, format: :json)
```

![](https://i.imgur.com/9YnQP1l.png)

## 帶kanban id進dataset

```
require("@rails/ujs").start()
require("turbolinks").start()
require("@rails/activestorage").start()
require("channels")

const images = require.context('../images', true)
const imagePath = (name) => images(name, true)

import 'scripts'
import 'styles'

import Vue from "vue/dist/vue.esm";
import Column from "components/kanban/column"
import Rails from '@rails/ujs'

document.addEventListener("turbolinks:load", () => {
  let el = document.querySelector("#column");
  if (el){
    new Vue({
      el,
      data: {
        // columns: JSON.parse(el.dataset.columns)
        kanban_id: el.dataset.kanbanid,
        columns: []
      },
      components: { Column },
      methods: {

      },
      beforeMount(){
        // 打API
        Rails.ajax({
          url: `/kanbans/${this.kanban_id}/columns.json`,
          type: 'GET',
          dataType: 'json',
          success: result => {
            console.log(this.kanban_id);
            console.log(result);
          },
          error: error => {
            console.log(error);            
          }
        });
      }
    });
  }
})
```

app.views.columns.index.html.erb
```
<div id="column" class="mt-2 px-3 flex" data-columns="<%= @columns.to_json(include: :tickets)%>" data-kanbanid="<%= @kanban.id%>" >
  <Column v-for="column in columns" :column="column" :key="column.id"></Column>  
</div>
```

columns_controller
```
  def index
    @kanban = Kanban.find(params[:kanban_id])    
    @columns = @kanban.columns.all
  end
```

完成圖：

![](https://i.imgur.com/c6bZYD9.png)

Column的元件搞定啦～～


~

# Vue元件: Column

接下來就是重頭戲了！準備好了路徑，我們該如何設計column這個元件呢？


## 作法一：使用props讓父層傳資料給子層

在[第9天鐵人賽](https://ithelp.ithome.com.tw/articles/10242337)，曾經練習用`props`在Vue裡不同的元件裡傳遞資料。


1. `Vue app`的掛載點：

`columns#index.html.erb`

```
<div id="column" class="mt-2 px-3 flex" data-columns="<%= @columns.to_json%>">
  <Column v-for="column in columns" :column="column" :key="column.id"></Column>  
</div>
```

2. 設計column元件
components/kanban/column.vue
```
<template>
  <div class="column">
    <div class="column-name">{{ column.name }}</div>
  </div>
</template>

<script>
  // 讓用元件的父層，餵資料給子元件
  export default {              
    name: 'Column',
    props: ["column"]
    // 每個元件都有自己的狀態和資料，所以data需要給一個能return值回去的function, 
    // data: function () {
    //   return {
    //     column: this.column   
    //   }
    // }
  }
</script>

<style lang="scss" scoped>
  .column{
    @apply .bg-teal-100 .mx-2 .w-64 .rounded;

    .column-name{
      @apply .px-3 .py-2 .font-thin;
    }
  }
</style>
```


3. 引入元件

packs/application.js

```
require("@rails/ujs").start()
require("turbolinks").start()
require("@rails/activestorage").start()
require("channels")

const images = require.context('../images', true)
const imagePath = (name) => images(name, true)

import 'scripts'
import 'styles'

import Vue from "vue/dist/vue.esm";
import Column from "components/kanban/column"

document.addEventListener("turbolinks:load", () => {
  let el = document.querySelector("#column");
  if (el){
    new Vue({
      el,
      data: {
        columns: JSON.parse(el.dataset.columns)
      },
      components: { Column }
    });
  }
})
```

![](https://i.imgur.com/BDCuR5f.png)

如何不要用data-set來做component?

~

- getter: 透過`getter`拿資料資料出來
- mutation: 變更
- action: 呼叫mutation


# v-if 實作修改功能

漂亮的顏色
![](https://i.imgur.com/EPWh9Z4.png)

## 編輯區塊

按下卡片時，`editing=true`
```
<template>
  <div class="ticket">
    {{ ticket.name }}
    <div>
      <button class="edit-btn" @click="editTicket=true"><i class="fas fa-edit text-gray-400"></i></button>
      <button class="delete-btn" @click="removeTicketDemo(ticket)"><i class="fas fa-trash text-gray-400"></i></button>
      <div v-if="editTicket" class="edit-area">
        <i class="far fa-window-close edit-cancel" @click="cancelUpdate"></i> 
        <textarea type="text" class="edit-input" v-model="ticket.name"></textarea>
        <button class="update-ticket-btn" @click="updateTicket">更新</button>
      </div>        
    </div>
  </div>
</template>
```

```
<script>
  import Rails from '@rails/ujs';
  export default {              
    name: 'Ticket',
    props: ["ticket"],
    data: function () {
      return {
        column: this.ticket.column,
        editTicket: false
      }
    },    
    methods: {
      updateTicket(){

      },
      deleteTicket(evt){
        //刪除
      }
    }
  }
</script>
```

```
<style lang="scss" scoped>
  .ticket {
    @apply .bg-yellow-100 .mb-2 .rounded-md .px-2 .py-2 .font-thin .text-sm .shadow-lg;
    .delete-btn {
      border: 0;
    }
    .edit-area {
      @apply .bg-orange-200 .rounded-md .px-2 .py-2;
    }
    .edit-cancel{
      @apply .mb-2 .text-gray-800;
    }
    .edit-input{
      @apply .w-full .px-2 .py-1 .rounded-md .bg-yellow-100;
    }
    .update-ticket-btn{
      @apply .mx-1 .my-2 .px-2 .py-1 .bg-red-300 .rounded-md .text-sm .text-gray-800 .font-thin;
      &:hover {
        @apply .bg-red-200;
      }
    }
  }
</style>
```

蓋版
```
<style lang="scss" scoped>
  .ticket {
    @apply .bg-yellow-100 .mb-2 .rounded-md .px-2 .py-2 .font-thin .text-sm .shadow-lg;
    .delete-btn {
      border: 0;
    }
    .edit-area {
      background-color: rgba(13, 77, 52, 0.424);
      @apply .fixed .w-full .h-full .top-0 .left-0 .flex .items-center justify-center; 
    }
    .edit-cancel{
      @apply .m-2 .text-gray-800;
      width: 20px;
    }
    .edit-input{
      @apply .px-2 .py-1 .rounded-md .bg-yellow-100;
      width: 500px;
      height: 30px;
    }
    .update-ticket-btn{
      @apply .mx-1 .my-2 .px-2 .py-1 .bg-green-300 .rounded-md .text-sm .text-gray-800 .font-thin;
      &:hover {
        @apply .bg-green-200;
      }
    }
  }
</style>
```

---
title:  "[2020] 第12屆鐵人賽Day 29 Rails專案開發 - Action Cable即時互動功能: 以edit和delete ticket為例"
preview: ""
permalink: "/articles/2020-10-11"
date:   2020-10-10 10:00:00
layout: post
tags: 
  - "rail"
  - "vue"    
---

來到倒數第二天啦！感動流淚O_Q

前兩天裡用Vuex狀態管理的方式實作`編輯`和`刪除`ticket

本日想完成的功能：，利用Action Cable廣播，在任何的瀏覽器登入，都會同步顯示編輯和刪除的結果～讓使用者有即時互動的體驗！

如下圖所示，我開了兩個瀏覽器(Safari和chrome)，無論在哪個瀏覽器`編輯`或`刪除`ticket，另一個瀏覽器都會即時產生效果～

![](https://i.imgur.com/8b7UQPc.gif)

# WebSocket: 讓前端與後端沒有距離

WebSocket是能讓瀏覽器(Client端)與伺服器(Server端)持續進行`雙向資料傳遞`的通訊協定，Client端用Ajax非同步方式做請求， Server端也能主動發送Client所需要的資料。

相信大家都有聽過HTTP吧～HTTP是基於TCP(Transmission Control Protocol, 傳輸控制協定)進行「三向交握（3-way handshake）建立連線（A方提出請求、B方確認A的請求並提出自己請求、A方再確認一次B的請求，總共三次。）

而WebSocket是進階的網路應用層協議（在2011年由[IETF](https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%B7%A5%E7%A8%8B%E4%BB%BB%E5%8A%A1%E7%BB%84)標準化）。如果Client端初始化時HTTP標頭中含有WebSocket的資訊，當連線Client端到Server端，Server端會將HTTP連線升級為WebSocket的連接，並返回同樣包含websocket標頭資訊的HTTP回應，如此一來就能立即實現`持續的雙向溝通`，因此WebSocket常用來實作可以互相傳訊息的聊天室。

# ActionCable: 整合瀏覽器端JavaScript介面以及server端

ActionCable是建構於WebSocket上、Pub（消息發佈者）/Sub（消息訂閱者）模型的Ruby on Rails框架，Publisher和Subscriber會以javascript透過非同步(async)的方式傳遞訊息，使訊息傳遞不需等待回應就可進行後續操作（想像聊天的時候，你不用等收到別人訊息的時候才能傳出自己的訊息），非常便利！接下來今天的文章開始參考[Rails Guides: Action Cable](https://guides.rubyonrails.org/action_cable_overview.html) ，並使用`Redis`這款帶有`Pub/Sub`功能的資料庫實作。

# Step1. 設定Server端連線

通常看到網路上的教學步驟，都會請你先new一個rails專案、建立User model以及必要的controller。
由於我們現在這個鐵人賽專案已經有了很多個controller（kanban, column, ticket...XD），就直接挑比較符合業務邏輯的controller加上channel。

首先我來`rails g channel`建立一個channel，名叫`column` 

```
rails g channel column

Running via Spring preloader in process 70377
      invoke  rspec
      create    spec/channels/column_channel_spec.rb
      create  app/channels/column_channel.rb
```

## 1-1 訂閱頻道

接著來修改`channels/column_channel.rb`這個檔案，在裡面指定訂閱的頻道是剛剛建立的`column` 
```
class ColumnChannel < ApplicationCable::Channel
  def subscribed
    stream_from "column"
  end

  def unsubscribed
  end
end
```

## 1-2 建立連線前，進行身份驗證

想像一個軟體有群組聊天以及私人一對一聊天的功能，我們需要符合身份的人（也就是有`訂閱`這個頻道的人），有值的話才能回傳給他特定的訊息，不然就拒絕連線。
那要怎麼實作這個功能呢？

最一開始使用Rails的`devise gem`製作註冊登入系統，裡已經提供給我們適當的環境變數`env["warden"]`。
在這裡，把它透過`byebug`印出來看看:

```
10:49:52 web.1       | (byebug) env["warden"]
10:49:52 web.1       | Warden::Proxy:70111027317460 @config={:default_scope=>:user, :scope_defaults=>{}, :default_strategies=>{:user=>[:rememberable, :database_authenticatable]}, :intercept_401=>false, :failure_app=>#<Devise::Delegator:0x00007f87fa2cc638>}

10:49:52 web.1       | (byebug) env["warden"].user
10:50:30 web.1       | #<User id: 1, email: "tingtinghsu[at]秘密", created_at: "2020-10-01 01:43:03", updated_at: "2020-10-01 07:12:27", name: "Ting">
```

我們在`channels/application_cable/connection.rb`，如果`env["warden"].user`有值，指定給`current_user`

```
module ApplicationCable
  class Connection < ActionCable::Connection::Base
    identified_by :current_user

    #這裡引入current_user
    def connect
      self.current_user = find_verified_user
    end

    private
      def find_verified_user
        if current_user = env["warden"].user
          current_user
        else
          reject_unauthorized_connection
        end
      end
  end
  end
end

```

# Step 2. 設定client端連線

接下來是瀏覽器端了！

## 2-1 Consumer.js (Rails的產生預設檔案)

雖然這一份js檔案不是我們自己寫的，不過還是可以來研究一下大神們開發的架構，這個檔案會讓consumer預設與server的cable做連線。

```
// Action Cable provides the framework to deal with WebSockets in Rails.
// You can generate new channels where WebSocket features live using the `rails generate channel` command.

import { createConsumer } from "@rails/actioncable"
export default createConsumer()
```

## 2-2 Consumer連線後，會成為Subscriber`訂閱者`：建立 column_channel.js

Consumer連線後成為Subscriber後就會進來這裡。有三個部分：`connected()`、`received(data)`、`disconnected()`
我們可以在瀏覽器的dev tool裡console分別印出連線狀況，幫助我們debug。

`app/frontend/channel/column.js`
```
import consumer from "./consumer"
console.log("loading")

consumer.subscriptions.create("ColumnChannel", {
  connected() {
    console.log("connected")
  },

  received(data) {
    console.log("Welcome to ColumnChannel")    
    console.log(data)

    if(data.commit){
      //等等會用到這個區塊 
    }
  },

  disconnected() {
    console.log("disconnected")
  }
});
```

![](https://i.imgur.com/BqI4Oys.gif)

# Step 3. Rails MVC: 透過 controller 廣播

## 3-1 統一讓後端資料變更成功時廣播送出commit

把專案的編輯刪除ticket的controller動作結合action cable，資料更動成功的話，透過`ActionCable.server.broadcast`對`column channel`做廣播，要commit的那一包payload為轉為string的`:show.json`。

```
  def update
    respond_to do |format|
      if @ticket.update(ticket_params)     
      ActionCable.server.broadcast("column", { commit: 'UPDATE_TICKET', payload: render_to_string(:show, format: :json)})        
        format.json { render :show, status: :ok}
      else
        format.json { render json: @ticket.errors, status: :unprocessable_entity }
      end
    end
  end

  def destroy
    @ticket.destroy
    respond_to do |format|
      puts "destroy success"
      ActionCable.server.broadcast("column", { commit: 'DELETE_TICKET', payload: render_to_string(:show, format: :json)})       
      format.json { head :no_content }      
    end
  end
```
ps.這邊的點我卡了幾個小時，因為一直沒有render出自己要的json檔，後來發現要把scaffold長出來沒用到的html.erb先刪掉，Rails才不會找錯檔案。

## 3-2 修改Vuex action，前端打資料去後端時不需重複commit

記得把原本Vuex action內的commit註解掉，因為現在我們已經透過controller進行全域的廣播了（不然會操作的那一方瀏覽器會commit兩次）
```
  actions: {
    updateTicket({ commit }, {id, name}){
      // 略
      Rails.ajax({
        url: `/kanbans/${el.dataset.kanbanid}/tickets/${id}`,
        type: 'PUT',
        data,
        dataType: 'json',
        success: result => {
          // commit("UPDATE_TICKET", result);
          console.log(result);
        },
        error: error => {
          console.log(error);            
        }
      });      
    },
    deleteTicket({ commit }, {ticket_id, column_id}){
      //略
      Rails.ajax({
        url: `/kanbans/${el.dataset.kanbanid}/tickets/${ticket_id}`,
        type: 'DELETE',
        dataType: 'json',
        success: result => {
          // commit("DELETE_TICKET", {ticket_id, column_id});
        },
        error: error => {
          console.log(error)
        }
      });
    },
```



# Step 4. Subscriber`訂閱者收到commit過後的data


# 讓Vuex的`$store`變成全域變數，在channel.js裡拿到

之前做專案時，如果是透過webpacker引入jQuery套件，有一個~~偷吃步的~~方法可以把`$`字符號設為全域都可使用
就是在`application.js`加上`window.$ = $`
```
import $ from 'jquery'
window.$ = $
```

那，為了讓我們可以在`Action Cable`的client端也可以對store做事情，
如法炮製，在`application.js`這個Vue的掛載點加上這句：

```
window.$store = store;
```


把string再轉為json檔

`app/frontend/channel/column.js`
```
import consumer from "./consumer"

consumer.subscriptions.create("ColumnChannel", {
  connected() {
  },

  received(data) {
    if(data.commit){
      console.log("data commit!")
      window.$store.commit(data.commit, JSON.parse(data.payload));      
    }
  },

  disconnected() {

  }
});
```


完成摟！在哪個瀏覽器`編輯`或`刪除`ticket，另一個瀏覽器都會即時產生效果～

![](https://i.imgur.com/8b7UQPc.gif)

實作完今天的單元後，又對於WebSocket這個瀏覽器(Client端)與伺服器(Server端)進行`雙向資料傳遞`的通訊協定更加清晰了！


心得：

1. 這並不是我第一次實做action cable，但是第一次透過結合Vuex狀態管理來做`ActionCable.server.broadcast`，算是一個自己的大突破～～本來預計想做的是拖拉的action cable即時效果（但還沒克服bug）緊急換成實作`刪除ticket`和`修改ticket`的即時互動效果～終於在自己規定的時限內研究出來+把文章寫好。
2. 後來發現Vue自己也有[actioncable-vue](https://github.com/mclintprojects/actioncable-vue) 的套件，鐵人賽結束後我也會來玩玩看！



* [Rails Guides: Action Cable](https://guides.rubyonrails.org/action_cable_overview.html)  

* [[Rails] Actioncable 即時通訊](https://guides.rubyonrails.org/action_cable_overview.html)  

* [JavaScript | WebSocket 讓前後端沒有距離](https://medium.com/enjoy-life-enjoy-coding/javascript-websocket-%E8%AE%93%E5%89%8D%E5%BE%8C%E7%AB%AF%E6%B2%92%E6%9C%89%E8%B7%9D%E9%9B%A2-34536c333e1b)  

* [TCP 三向交握 (Three-way Handshake)](https://notfalse.net/7/three-way-handshake)  

* [actioncable-vue](https://github.com/mclintprojects/actioncable-vue)  